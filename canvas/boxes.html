<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Boxes</title>
  <meta name="viewport" content="width=device-width" />
  <style>
    html, body {
      height: 100vh;
    }
    canvas {
      border: 1px solid black;
    }
    button {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>Boxes</h1>
  <canvas id="canvas"></canvas>
  <button id="fadeButton">Fade First Rectangle</button>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const fadeButton = document.getElementById('fadeButton');
    const CELL_WIDTH = 30;
    const CELL_HEIGHT = 30;
    const cellStyles = Object.freeze({
      INIT: {
        dashed: true,
      },
      MARKED: {
        dashed: false,
      },
      ONE_LEFT: {
        dashed: false,
        glowOffset: 7,
        glowRBG: [255, 172, 67],
      },
    });

    canvas.setAttribute('width', '480');
    canvas.setAttribute('height', '120');

    // Takes effect after canvas.setAttribute
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = '18px Roboto, Arial';

    const cells = [{
      x: 10,
      y: 10,
      number: 23,
      cellStyle: 'INIT',
      taskStack: [],
    }, {
      x: 50,
      y: 10,
      number: 34,
      cellStyle: 'MARKED',
      taskStack: [],
    }, {
      x: 130,
      y: 10,
      number: 45,
      cellStyle: 'ONE_LEFT',
      taskStack: [],
    }];

    function processTask(cell) {
      const { taskStack = [] } = cell;
      if (!taskStack.length) return;
      const task = taskStack.pop();

      cell.cellStyle = task.cellStyle || cell.cellStyle;

      if (task.taskType === 'updateCellType') return;

      if (task.taskType === 'fadeOut') {
        if (task.processingStartTime) {
          const elapsed = Date.now() - task.processingStartTime;
          if (elapsed > task.durationInMilliSeconds) return;
          cell.opacity = 1 - elapsed / task.durationInMilliSeconds;
        } else {
          task.processingStartTime = Date.now();
        }
        taskStack.push(task);
        return;
      }

      if (task.taskType === 'fadeOut') {
        if (task.processingStartTime) {
          const elapsed = Date.now() - task.processingStartTime;
          if (elapsed > task.durationInMilliSeconds) return;
          cell.opacity = 1 - elapsed / task.durationInMilliSeconds;
        } else {
          task.processingStartTime = Date.now();
          cell.opacity = 1;
        }
        taskStack.push(task);
        return;
      }

      if (task.taskType === 'fadeIn') {
        if (task.processingStartTime) {
          const elapsed = Date.now() - task.processingStartTime;
          if (elapsed > task.durationInMilliSeconds) return;
          cell.opacity = elapsed / task.durationInMilliSeconds;
        } else {
          task.processingStartTime = Date.now();
          cell.opacity = 0;
        }
        taskStack.push(task);
        return;
      }
    }

    function drawRoundedRect({
      x,
      y,
      width = CELL_WIDTH,
      height = CELL_HEIGHT,
      radius = 6,
      glowOffset = 0,
      glowRBG = [],
      dashed = false,
      clipped = false,
    }) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();

      ctx.setLineDash(dashed ? [4, 4] : []);

      if (clipped) return ctx.clip();

      ctx.fill();

      if (glowOffset && glowRBG.length) {
        ctx.save();
        ctx.clip();

        const startRGBA = `rgba(${glowRBG[0]}, ${glowRBG[1]}, ${glowRBG[2]}, 0.50)`;
        const endRGBA = `rgba(${glowRBG[0]}, ${glowRBG[1]}, ${glowRBG[2]}, 0)`;
        const rightGlow = ctx.createLinearGradient(
          x + width, y, x + width - glowOffset, y
        );
        rightGlow.addColorStop(0, startRGBA);
        rightGlow.addColorStop(1, endRGBA);
        ctx.fillStyle = rightGlow;
        ctx.fillRect(x + width - glowOffset * 2, y, glowOffset * 2, height);
  
        const bottomGlow = ctx.createLinearGradient(
          x, y + height, x, y + height - glowOffset
        );
        bottomGlow.addColorStop(0, startRGBA);
        bottomGlow.addColorStop(1, endRGBA);
        ctx.fillStyle = bottomGlow;
        ctx.fillRect(x, y + height - glowOffset * 2, width, glowOffset * 2);

        ctx.restore();
      }

      ctx.stroke();
    }

    function drawNumber({
      number,
      x,
      y,
      width = CELL_WIDTH,
      height = CELL_HEIGHT,
    }) {
      ctx.fillText(number, x + width / 2, 1 + y + height / 2);
    }

    function drawRectangles(timestamp) {
      ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas before redrawing

      let isTasksCompleted = true;
      cells.forEach(cell => {
        processTask(cell);
        ctx.globalAlpha = cell.opacity ?? 1;

        switch (cell.cellStyle) {
          case 'MARKED':
            ctx.fillStyle = "#FFAC43";
            ctx.strokeStyle = "#EA8C15";
            drawRoundedRect({ ...cell, ...cellStyles[cell.cellStyle] });
            ctx.fillStyle = "#933807";
            drawNumber(cell);
            break;

          case 'ONE_LEFT':
            ctx.fillStyle = "#FFFFFF";
            ctx.strokeStyle = "#FFAC43";
            drawRoundedRect({ ...cell, ...cellStyles[cell.cellStyle] });

            ctx.fillStyle = "#FF5900";
            drawNumber(cell);
            break;

          case 'INIT':
            ctx.fillStyle = "rgba(131, 158, 230, 0.5)";
            ctx.strokeStyle = "#839EE6";
            drawRoundedRect({ ...cell, ...cellStyles[cell.cellStyle] });
            ctx.fillStyle = "#2B4995";
            drawNumber(cell);
            break;

          default: // NONE
            break;
        }

        ctx.globalAlpha = 1;
        if (cell.taskStack?.length) isTasksCompleted = false;
      });

      if (!isTasksCompleted) requestAnimationFrame(drawRectangles);
    }

    drawRectangles(); // Initial draw

    fadeButton.addEventListener('click', () => {
      // FILO
      // cells[0].taskStack.push({
      //   taskType: 'fadeIn',
      //   durationInMilliSeconds: 100,
      //   cellStyle: 'MARKED',
      // }, {
      //   taskType: 'fadeOut',
      //   durationInMilliSeconds: 100,
      //   cellStyle: 'INIT',
      // });

      // cells[0].taskStack.push({
      //   taskType: 'fadeIn',
      //   durationInMilliSeconds: 200,
      //   cellStyle: 'MARKED',
      // }, {
      //   taskType: 'updateCellType',
      //   cellStyle: 'NONE'
      // });

      cells[0].taskStack.push({
        taskType: 'fadeIn',
        durationInMilliSeconds: 300,
        cellStyle: 'ONE_LEFT',
      }, {
        taskType: 'updateCellType',
        cellStyle: 'NONE'
      }, {
        taskType: 'fadeIn',
        durationInMilliSeconds: 200,
        cellStyle: 'MARKED',
      }, {
        taskType: 'updateCellType',
        cellStyle: 'NONE'
      });

      cells[2].taskStack.push({
        taskType: 'fadeIn',
        durationInMilliSeconds: 100,
        cellStyle: 'MARKED',
      }, {
        taskType: 'fadeOut',
        durationInMilliSeconds: 30,
        cellStyle: 'ONE_LEFT',
      }, {
        taskType: 'fadeIn',
        durationInMilliSeconds: 100,
        cellStyle: 'ONE_LEFT',
      }, {
        taskType: 'fadeOut',
        durationInMilliSeconds: 30,
        cellStyle: 'MARKED',
      }, {
        taskType: 'fadeIn',
        durationInMilliSeconds: 100,
        cellStyle: 'MARKED',
      }, {
        taskType: 'fadeOut',
        durationInMilliSeconds: 30,
        cellStyle: 'ONE_LEFT',
      }, {
        taskType: 'fadeIn',
        durationInMilliSeconds: 100,
        cellStyle: 'ONE_LEFT',
      }, {
        taskType: 'fadeOut',
        durationInMilliSeconds: 30,
        cellStyle: 'MARKED',
      }, {
        taskType: 'fadeIn',
        durationInMilliSeconds: 100,
        cellStyle: 'MARKED',
      }, {
        taskType: 'fadeOut',
        durationInMilliSeconds: 30,
        cellStyle: 'ONE_LEFT',
      });

      requestAnimationFrame(drawRectangles);
    });
  </script>
</body>
</html>
