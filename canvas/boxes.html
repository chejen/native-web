<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Boxes</title>
  <meta name="viewport" content="width=device-width" />
  <style>
    html, body {
      height: 100vh;
    }
    button {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
    }
    #gridCanvas {
      transform-origin: top left;
      transform: scale(0.5);
    }
  </style>
</head>
<body>
  <h1>Boxes</h1>
  <canvas id="canvas"></canvas>
  <button id="fadeButton">Fade First Rectangle</button>

  <br />
  <canvas id="gridCanvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const fadeButton = document.getElementById('fadeButton');
    const CELL_WIDTH = 30;
    const CELL_HEIGHT = 30;
    const cellStyles = Object.freeze({
      INIT: {
        dashed: true,
      },
      MARKED: {
        dashed: false,
      },
      BINGO: {
        dashed: false,
      },
      ONE_LEFT_PLACEHOLDER: {
        dashed: false,
      },
      ONE_LEFT: {
        dashed: false,
        glowOffset: 7,
        glowRBG: [255, 172, 67],
      },
    });

    canvas.setAttribute('width', '480');
    canvas.setAttribute('height', '120');

    // Takes effect after canvas.setAttribute
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = '18px Roboto, Arial';

    const cells = [{
      x: 10,
      y: 10,
      number: 23,
      cellStyle: 'INIT',
      taskStack: [],
    }, {
      x: 50,
      y: 10,
      number: 34,
      cellStyle: 'INIT',
      taskStack: [],
    }, {
      x: 90,
      y: 10,
      number: 76,
      cellStyle: 'MARKED',
      taskStack: [],
    }, {
      x: 130,
      y: 10,
      number: 45,
      cellStyle: 'ONE_LEFT',
      taskStack: [],
    }, {
      x: 170,
      y: 10,
      number: 12,
      cellStyle: 'INIT',
      taskStack: [],
    }, {
      x: 210,
      y: 10,
      number: 89,
      cellStyle: 'BINGO',
      taskStack: [],
    }];

    function beforeRenderCell(cell) {
      const { taskStack = [] } = cell;
      if (!taskStack.length) return;
      const task = taskStack.pop();

      cell.cellStyle = task.cellStyle || cell.cellStyle;

      if (task.taskType === 'updateCellType') return;

      if (['fadeOut', 'fadeIn', 'fadedZoom'].includes(task.taskType)) {
        const now = Date.now();
        if (!task.processingStartTime) task.processingStartTime = now;

        const elapsed = now - task.processingStartTime;
        if (elapsed > task.durationInMilliSeconds) return;

        if (task.taskType === 'fadeIn') {
          cell.opacity = elapsed / task.durationInMilliSeconds;
        } else if (task.taskType === 'fadeOut') {
          cell.opacity = 1 - elapsed / task.durationInMilliSeconds;
        } else if (task.taskType === 'fadedZoom') {
          // Fade out while scaling up
          cell.opacity = 1 - elapsed / task.durationInMilliSeconds;
          cell.scale = 1 + (task.scale - 1) * (elapsed / task.durationInMilliSeconds);
        }

        taskStack.push(task);
      }
    }

    function renderCell(cell, isZooming = false) {
      ctx.save();
      ctx.globalAlpha = cell.opacity ?? 1;

      // For fadedZoom animation, there're two layers,
      // one is the original cell, the other is the zoomed cell.
      if (cell.scale) {
        if (isZooming) {
          // zoomed cell
          const centerX = cell.x + CELL_WIDTH / 2;
          const centerY = cell.y + CELL_HEIGHT / 2;
          ctx.translate(centerX, centerY);
          ctx.scale(cell.scale ?? 1, cell.scale ?? 1);
          ctx.translate(-centerX, -centerY);
        } else {
          // original cell
          ctx.globalAlpha = 1;
        }
      }

      switch (cell.cellStyle) {
        case 'BINGO':
        case 'MARKED':
        case 'ONE_LEFT_PLACEHOLDER':
          ctx.fillStyle = cell.cellStyle === 'BINGO' ? '#FFD043' : '#FFAC43';
          ctx.strokeStyle = cell.cellStyle === 'MARKED' ? '#EA8C15' : '#FFFFFF';
          drawRoundedRect({ ...cell, ...cellStyles[cell.cellStyle] });
          ctx.fillStyle = '#933807';
          if (!isZooming) drawNumber(cell);
          break;

        case 'ONE_LEFT':
          ctx.fillStyle = '#FFFFFF';
          ctx.strokeStyle = '#FFAC43';
          drawRoundedRect({ ...cell, ...cellStyles[cell.cellStyle] });
          ctx.fillStyle = '#FF5900';
          drawNumber(cell);
          break;

        case 'INIT':
          ctx.fillStyle = 'rgba(131, 158, 230, 0.5)';
          ctx.strokeStyle = '#839EE6';
          drawRoundedRect({ ...cell, ...cellStyles[cell.cellStyle] });
          ctx.fillStyle = '#2B4995';
          drawNumber(cell);
          break;

        default:
          break;
      }

      ctx.restore();
    }

    function drawRoundedRect({
      x,
      y,
      width = CELL_WIDTH,
      height = CELL_HEIGHT,
      radius = 6,
      glowOffset = 0,
      glowRBG = [],
      dashed = false,
      clipped = false,
    }) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();

      ctx.setLineDash(dashed ? [4, 4] : []);

      if (clipped) return ctx.clip();

      ctx.fill();

      if (glowOffset && glowRBG.length) {
        ctx.save();
        ctx.clip();

        const startRGBA = `rgba(${glowRBG[0]}, ${glowRBG[1]}, ${glowRBG[2]}, 0.50)`;
        const endRGBA = `rgba(${glowRBG[0]}, ${glowRBG[1]}, ${glowRBG[2]}, 0)`;
        const rightGlow = ctx.createLinearGradient(
          x + width, y, x + width - glowOffset, y
        );
        rightGlow.addColorStop(0, startRGBA);
        rightGlow.addColorStop(1, endRGBA);
        ctx.fillStyle = rightGlow;
        ctx.fillRect(x + width - glowOffset * 2, y, glowOffset * 2, height);
  
        const bottomGlow = ctx.createLinearGradient(
          x, y + height, x, y + height - glowOffset
        );
        bottomGlow.addColorStop(0, startRGBA);
        bottomGlow.addColorStop(1, endRGBA);
        ctx.fillStyle = bottomGlow;
        ctx.fillRect(x, y + height - glowOffset * 2, width, glowOffset * 2);

        ctx.restore();
      }

      ctx.stroke();
    }

    function drawNumber({
      number,
      x,
      y,
      width = CELL_WIDTH,
      height = CELL_HEIGHT,
    }) {
      ctx.fillText(number, x + width / 2, 1 + y + height / 2);
    }

    function drawRectangles(timestamp) {
      ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas before redrawing
      ctx.fillStyle = '#D2D9FB';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      let isTasksCompleted = true;
      cells.forEach(cell => {
        beforeRenderCell(cell);
        if (cell.scale) renderCell(cell, true);
        renderCell(cell);
        if (cell.taskStack?.length) isTasksCompleted = false;
      });

      if (!isTasksCompleted) requestAnimationFrame(drawRectangles);
    }

    drawRectangles(); // Initial draw

    fadeButton.addEventListener('click', () => {
      // FILO
      cells[0].taskStack.push({
        taskType: 'fadeIn',
        durationInMilliSeconds: 100,
        cellStyle: 'MARKED',
      }, {
        taskType: 'fadeOut',
        durationInMilliSeconds: 100,
        cellStyle: 'INIT',
      });

      // cells[0].taskStack.push({
      //   taskType: 'fadeIn',
      //   durationInMilliSeconds: 200,
      //   cellStyle: 'MARKED',
      // }, {
      //   taskType: 'updateCellType',
      //   cellStyle: 'NONE'
      // });

      cells[1].taskStack.push({
        taskType: 'fadeIn',
        durationInMilliSeconds: 250,
        cellStyle: 'ONE_LEFT',
      }, {
        taskType: 'fadeOut',
        durationInMilliSeconds: 50,
        cellStyle: 'ONE_LEFT_PLACEHOLDER',
      }, {
        taskType: 'fadeIn',
        durationInMilliSeconds: 150,
        cellStyle: 'ONE_LEFT_PLACEHOLDER',
      }, {
        taskType: 'fadeOut',
        durationInMilliSeconds: 50,
        cellStyle: 'INIT',
      });

      cells[2].taskStack.push({
        taskType: 'fadeIn',
        durationInMilliSeconds: 100,
        cellStyle: 'MARKED',
      }, {
        taskType: 'fadeOut',
        durationInMilliSeconds: 30,
        cellStyle: 'ONE_LEFT',
      }, {
        taskType: 'fadeIn',
        durationInMilliSeconds: 100,
        cellStyle: 'ONE_LEFT',
      }, {
        taskType: 'fadeOut',
        durationInMilliSeconds: 30,
        cellStyle: 'MARKED',
      }, {
        taskType: 'fadeIn',
        durationInMilliSeconds: 100,
        cellStyle: 'MARKED',
      }, {
        taskType: 'fadeOut',
        durationInMilliSeconds: 30,
        cellStyle: 'ONE_LEFT',
      }, {
        taskType: 'fadeIn',
        durationInMilliSeconds: 100,
        cellStyle: 'ONE_LEFT',
      }, {
        taskType: 'fadeOut',
        durationInMilliSeconds: 30,
        cellStyle: 'MARKED',
      }, {
        taskType: 'fadeIn',
        durationInMilliSeconds: 100,
        cellStyle: 'MARKED',
      }, {
        taskType: 'fadeOut',
        durationInMilliSeconds: 30,
        cellStyle: 'ONE_LEFT',
      });

      cells[4].taskStack.push({
        taskType: 'fadedZoom',
        scale: 1.6,
        durationInMilliSeconds: 250,
        cellStyle: 'BINGO',
      }, {
        taskType: 'fadeOut',
        durationInMilliSeconds: 50,
        cellStyle: 'INIT',
      });

      requestAnimationFrame(drawRectangles);
    });


    // Second canvas (grid layout)
    const dpr = window.devicePixelRatio || 1;
    const gridCanvas = document.getElementById('gridCanvas');
    const gridCtx = gridCanvas.getContext('2d');
    const rows = 3;
    const columns = 9;
    const gridPadding = 1;
    const cellPadding = 4;
    const cellBorderWidth = 1;
    const gridWidth = 272;
    const gridHeight = 68;
    const gridCellWidth = (gridWidth - gridPadding * 2 - cellPadding * (columns - 1)) / columns;
    const gridCellHeight = (gridHeight - gridPadding * 2 - cellPadding * (rows - 1)) / rows;

    gridCanvas.setAttribute('width', gridWidth * dpr);
    gridCanvas.setAttribute('height', gridHeight * dpr);
    gridCanvas.style.width = gridWidth + 'px';
    gridCanvas.style.height = gridHeight + 'px';
    gridCtx.scale(dpr, dpr);
    
    gridCtx.fillStyle = '#D2D9FB';
    gridCtx.fillRect(0, 0, gridWidth, gridHeight);

    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < columns; col++) {
        const x = gridPadding + col * (gridCellWidth + cellPadding);
        const y = gridPadding + row * (gridCellHeight + cellPadding);

        gridCtx.fillStyle = 'pink';
        gridCtx.fillRect(x, y, gridCellWidth, gridCellHeight);
        gridCtx.strokeStyle = 'purple';
        gridCtx.strokeRect(x, y, gridCellWidth, gridCellHeight);

        gridCtx.font = '12px Roboto, Arial';
        gridCtx.textAlign = 'center';
        gridCtx.textBaseline = 'middle';
        gridCtx.fillStyle = 'purple';
        gridCtx.fillText(row * columns + col, x + gridCellWidth / 2, y + gridCellHeight / 2);
      }
    }
  </script>
</body>
</html>
